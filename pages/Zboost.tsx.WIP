import React, { useEffect, useState, useCallback } from "react";
import {
  useAccount,
  useWaitForTransactionReceipt,
  usePrepareContractWrite,
  useNetwork,
  useWriteContract,
  useSendTransaction,
} from "wagmi";
import { ethers } from "ethers";
import { ABI, CONFIG, ADDRESS } from "../constants/constants";
import { CONTRACTS } from "../constants/contracts";
import { PROVIDERS } from "../constants/providers";
import { MyConnect } from "../components/connectButton";
import Layout from ".";
import Image from "next/image";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import {
  faCopy,
  faTicket,
  faWallet,
  faUpRightFromSquare,
  faExclamationCircle,
} from "@fortawesome/free-solid-svg-icons";
import donut from "/public/images/pooltogether.png";
import { useRouter } from "next/router";
import { ToastContainer, toast } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import { GetBoosterEvents } from "../utils/getBoosterClaimEvents";
import PrizeTokenBalance from "../components/prizeTokenBalance";
import PrizeIcon from "../components/prizeIcon";
import { Multicall } from "../utils/multicall";
import { PrizeToke } from "../utils/tokenMaths";

const MAX_ETH_FUNDING = 20;
const MIN_ETH_FUNDING = 0.1;
const MAX_CLAIM_COST = 1;
const DEFAULT_MAX_CLAIM_COST = 1;

function CopyToClipboardButton(text: any) {
  navigator.clipboard
    .writeText(text)
    .then(() => {
      console.log("Text successfully copied to clipboard");
    })
    .catch((err) => {
      console.error("Could not copy text: ", err);
    });
}

interface AddressRowProps {
  name: string;
  address: string;
}

const AddressRow: React.FC<AddressRowProps> = ({ name, address }) => {
  return (
    <div className="address-row">
      <span className="address-label">{name}</span>
      <span className="address-data small-font">
        <span className="hidden-mobile">{address} </span>
        <span className="hidden-desktop">{address.substring(0, 12)}... </span>

        <FontAwesomeIcon
          icon={faCopy}
          size="sm"
          style={{
            cursor: "pointer",
            color: "#21325c",
            height: "14px",
            marginRight: "5px",
            marginLeft: "5px",
          }}
          onClick={() => CopyToClipboardButton(address)}
        />
        <a
          href={`${ADDRESS[CONFIG.CHAINNAME].ETHERSCAN}/address/${address}`}
          target="_blank"
          rel="noreferrer">
          <Image
            src="/images/etherscan.svg"
            height={14}
            width={14}
            alt="etherscan"
          />
        </a>
      </span>
    </div>
  );
};

export interface NewWinBoostEvent {
  owner: string;
  claimer: string;
  contractAddress: string;
}

export interface ClaimFundContract {
  contractAddress: string;
  maxClaimCost: ethers.BigNumber;
  winner: string;
}

const isValidEthFunding = (input: any, balance: any) => {
  const number = parseFloat(input);
  const walletBalance = parseFloat(balance) / 1e18;
  console.log("number", number, "wallet", walletBalance);
  console.log(number < walletBalance);
  return (
    !isNaN(number) &&
    number >= MIN_ETH_FUNDING &&
    number <= MAX_ETH_FUNDING &&
    number < walletBalance
  );
};
const isValidNumberInput = (input: any) => {
  if (input === "" || input === ".") return true; // Allow empty input or solitary decimal
  return /^-?\d*\.?\d*$/.test(input); // Allow numbers with or without decimal point
};

const isNumericInput = (value: any) => {
  return /^-?\d*\.?\d*$/.test(value);
};

const isValidMaxClaimCost = (input: any) => {
  const number = parseFloat(input);
  return !isNaN(number) && number > 0 && number <= MAX_CLAIM_COST;
};

const WinBoostComponent: React.FC = () => {
  const { chain } = useNetwork();
  const router = useRouter();

  const { isConnected, address } = useAccount();
  // const [userContracts, setUserContracts] = useState<ClaimFundContract[]>([]);
  const [fundContractAddress, setFundContractAddress] = useState("");
  // const [selectedContract, setSelectedContract] = useState<ClaimFundContract | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [ethBalance, setEThBalance] = useState<string>("");
  const [poolAllowance, setPoolAllowance] = useState<ethers.BigNumber>()
  const [contractEthBalance, setContractEthBalance] = useState<string>("");
  const [ethToAdd, setEthToAdd] = useState<string>(MIN_ETH_FUNDING.toString());
  const [maxClaimCost, setMaxClaimCost] = useState<string>("0");
  // const [winnerAddress, setWinnerAddress] = useState<string>("");
  const [ownerAddress, setOwnerAddress] = useState<string>("");
  // const [claimerAddress, setClaimerAddress] = useState<string>(
  //   "0xE5860FF1c57DDCEF024Cb43B37b8A20bfE4c9822"
  // );
  const [refresh, setRefresh] = useState<boolean>(true);
  const [isCreatingNew, setIsCreatingNew] = useState(false);
  const [boostedClaims, setBoostedClaims] = useState([]);

  const prepareValueForTransaction = (value: any) => {
    if (!value || isNaN(parseFloat(value))) {
      return BigInt(0);
    }
    return BigInt(ethers.utils.parseEther(value).toString());
  };
  console.log("eth balance", ethBalance);
  console.log(parseFloat(ethToAdd), ">", parseFloat(ethBalance) / 1e18);
  // const { config } = usePrepareSendTransaction({
  //     to: fundContractAddress,
  //     value: prepareValueForTransaction(ethToAdd),
  // });
  // console.log("config to",config.to)
  // console.log("config value",config.value)

  const {
    data,
    sendTransaction,
    isLoading: isSendingEth,
  } = useSendTransaction();

  // console.log("send tx",sendTransaction)
  // const handleSendEth = useCallback(() => {
  //   // if(sendTransaction){console.log("send tx true")}else {console.log("NO send tx")}
  //   if (isValidNumberInput(ethToAdd)) {
  //     console.log("valid pool input");
  //   }
  //   if (fundContractAddress && isValidNumberInput(ethToAdd)) {
  //     try {
  //       sendTransaction?.({
  //         to: fundContractAddress,
  //         value: prepareValueForTransaction(ethToAdd),
  //         gas: BigInt(20000),
  //       });
  //     } catch (error) {
  //       console.error("Failed to send POOL:", error);
  //     }
  //   } else {
  //     console.log("bad number input to pool send");
  //   }
  // }, [ethToAdd, sendTransaction]);

  // console.log(
  //   "address",
  //   `0x${ADDRESS[CONFIG.CHAINNAME].WINBOOST.substring(2)}`
  // );
  // console.log("abi", ABI.WINBOOST);

  const valueInWei =
    ethToAdd && !isNaN(parseFloat(ethToAdd))
      ? ethers.utils.parseUnits(ethToAdd, "18")
      : ethers.utils.parseUnits("0", "18");
  const valueAsString = valueInWei.toString();
  const valueAsBigInt = BigInt(valueAsString);

  const claimvalueInWei =
    maxClaimCost && !isNaN(parseFloat(maxClaimCost))
      ? ethers.utils.parseUnits(maxClaimCost, "18")
      : ethers.utils.parseUnits("0", "18");
  const claimvalueAsString = claimvalueInWei.toString();
  const claimvalueAsBigInt = BigInt(claimvalueAsString);
  // console.log("withdraw pool from", `0x${fundContractAddress.substring(2)}`);

  const {
    data: withdrawData,
    write: withdrawEth,
    isLoading: isWithdrawingEth,
  } = useWriteContract({
    address: `0x${ADDRESS[CONFIG.CHAINNAME].WINBOOSTER.substring(2)}`,
    abi: ABI.WINBOOSTER,
    functionName: "withdrawPOOL",
    args: [],
    onSuccess(data) {
      console.log("POOL withdrawn");
    },
  });

  console.log("value as big int",valueAsBigInt.toString())
  const {
    data: depositData,
    write: depositPool,
    isLoading: isDepositingEth,
  } = useWriteContract({
    address: `0x${ADDRESS[CONFIG.CHAINNAME].WINBOOSTER.substring(2)}`,
    abi: ABI.WINBOOSTER,
    functionName: "depositPOOL",
    args: [valueAsBigInt, ownerAddress],
    onSuccess(data) {
      console.log("POOL deposited");
    },
  });

console.log("prize token",`0x${ADDRESS[CONFIG.CHAINNAME].PRIZETOKEN.ADDRESS.substring(2)}`)
console.log("boooooster",ADDRESS[CONFIG.CHAINNAME].WINBOOSTER)
  const {
    data: approveData,
    write: approvePool,
    isLoading: isApprovingPool,
  } = useWriteContract({
    address: `0x${ADDRESS[CONFIG.CHAINNAME].PRIZETOKEN.ADDRESS.substring(2)}`,
    abi: ABI.ERC20,
    functionName: "approve",
    args: [ ADDRESS[CONFIG.CHAINNAME].WINBOOSTER,(MAX_ETH_FUNDING*1e18*4).toString()],
    onSuccess(data) {
      console.log("POOL Approved");
    },
  });


  const {
    isLoading: poolApproveLoading,
    isSuccess: poolApproveSuccess,
    isFetching: poolApproveFetching,
  } = useWaitForTransactionReceipt({
    hash: approveData?.hash,
    onSuccess(data) {
      const etherscanLink = `${ADDRESS[CONFIG.CHAINNAME].ETHERSCAN}/tx/${depositData?.hash}`;
      toast(
        <>
          POOL approved! &nbsp;
          <a href={etherscanLink} target="_blank" rel="noopener noreferrer">
            <FontAwesomeIcon
              icon={faUpRightFromSquare}
              height={15}
              width={15}
            />
          </a>
        </>,
        { position: toast.POSITION.BOTTOM_LEFT }
      );
    },
  });


  console.log(ownerAddress,"depositing",valueAsBigInt.toString())
  const {
    isLoading: ethWithdrawLoading,
    isSuccess: ethWithdrawSucces,
    isFetching: ethWithdrawFetching,
  } = useWaitForTransactionReceipt({
    hash: withdrawData?.hash,
    onSuccess(data) {
      const etherscanLink = `${ADDRESS[CONFIG.CHAINNAME].ETHERSCAN}/tx/${withdrawData?.hash}`;
      toast(
        <>
          POOL withdraw! &nbsp;
          <a href={etherscanLink} target="_blank" rel="noopener noreferrer">
            <FontAwesomeIcon
              icon={faUpRightFromSquare}
              height={15}
              width={15}
            />
          </a>
        </>,
        { position: toast.POSITION.BOTTOM_LEFT }
      );
    },
  });
  const {
    isLoading: ethDepositLoading,
    isSuccess: ethDepositSucces,
    isFetching: ethDepositFetching,
  } = useWaitForTransactionReceipt({
    hash: depositData?.hash,
    onSuccess(data) {
      const etherscanLink = `${ADDRESS[CONFIG.CHAINNAME].ETHERSCAN}/tx/${depositData?.hash}`;
      toast(
        <>
          POOL deposited! &nbsp;
          <a href={etherscanLink} target="_blank" rel="noopener noreferrer">
            <FontAwesomeIcon
              icon={faUpRightFromSquare}
              height={15}
              width={15}
            />
          </a>
        </>,
        { position: toast.POSITION.BOTTOM_LEFT }
      );
    },
  });

  // const { config } = usePrepareContractWrite({
  //     address: `0x${ADDRESS[CONFIG.CHAINNAME].CLAIMSERVICEFACTORY.substring(2)}`,
  //     abi: ABI.CLAIMSERVICEFACTORY,
  //     functionName: 'newWinBoostContract',
  //     args: [  ownerAddress,winnerAddress,claimerAddress,ethers.utils.parseUnits(maxClaimCost.toString() || '0',18)
  // ],
  // value: BigInt(ethers.utils.parseUnits(ethToAdd,18).toString()),
  //   })

  const {
    data: newContractData,
    write: writeNewFundContract,
    isLoading: isWritingNewFundContract,
    error: createContractError,
  } = useWriteContract({
    address: `0x${ADDRESS[CONFIG.CHAINNAME].WINBOOSTER.substring(2)}`,
    abi: ABI.WINBOOSTER,
    functionName: "depositPOOL",
    args: [ownerAddress, valueAsBigInt],
    // value: valueAsBigInt,
  });

  const {
    isLoading: newWinBoostLoading,
    isSuccess: newWinBoostSucces,
    isFetching: newWinBoostFetching,
  } = useWaitForTransactionReceipt({
    hash: newContractData?.hash,
    onSuccess(data) {
      const etherscanLink = `${ADDRESS[CONFIG.CHAINNAME].ETHERSCAN}/tx/${newContractData?.hash}`;
      toast(
        <>
         Win Booster Funded! &nbsp;
          <a href={etherscanLink} target="_blank" rel="noopener noreferrer">
            <FontAwesomeIcon
              icon={faUpRightFromSquare}
              height={15}
              width={15}
            />
          </a>
        </>,
        { position: toast.POSITION.BOTTOM_LEFT }
      );
    },
  });

  const {
    data: updateMaxClaimCostData,
    write: updateMaxClaimCost,
    isLoading: updateMaxClaimCostIsLoading,
  } = useWriteContract({
    address: `0x${ADDRESS[CONFIG.CHAINNAME].WINBOOSTER.substring(2)}`,
    abi: ABI.WINBOOSTER,
    functionName: "setMaxFeePerPrize",
    args: [claimvalueAsBigInt],
    onSuccess(data) {
      console.log("maxClaimCost updated successfully");
    },
  });

  const {
    isLoading: updateClaimCostIsLoading,
    isSuccess: updateClaimCostIsSuccess,
    isFetching: updateClaimCostIsFetching,
  } = useWaitForTransactionReceipt({
    hash: updateMaxClaimCostData?.hash,
    onSuccess(data) {
      const etherscanLink = `${ADDRESS[CONFIG.CHAINNAME].ETHERSCAN}/tx/${updateMaxClaimCostData?.hash}`;
      toast(
        <>
          Max Claim Cost Updated! &nbsp;
          <a href={etherscanLink} target="_blank" rel="noopener noreferrer">
            <FontAwesomeIcon
              icon={faUpRightFromSquare}
              height={15}
              width={15}
            />
          </a>
        </>,
        { position: toast.POSITION.BOTTOM_LEFT }
      );
    },
  });

  // const { write: writeNewFundContract, isLoading: isWritingNewFundContract } = useWriteContract({

  // });

  // const { write: updateWinner, isLoading: updateWinnerIsLoading } = useWriteContract({
  //     address: `0x${fundContractAddress.substring(2)}`,
  //     abi: ABI.CLAIMFUND,
  //     functionName: 'updateWinner',
  //     args: [winnerAddress],
  //     onSuccess(data) {
  //         console.log("Winner updated successfully");
  //     },
  // });

  const createNewFundContract = () => {
    try {
      if (!chain || !address) {
        toast("error, see console", {
          position: toast.POSITION.BOTTOM_LEFT,
        });
        console.log("error create, wrong chain or address ");
        return;
      } else {
        // if (config) {
        writeNewFundContract();
        //   } else {
        //     console.log("write new fund contract is not defined");
        //     toast("error, see console", {
        //       position: toast.POSITION.BOTTOM_LEFT,
        //     });
        //   }
      }
    } catch (e) {
      console.log(e);
    }
  };

  const loadContractData = async (userAddress: string) => {
    // const contractInstance = new ethers.Contract(
    //   contractAddress,
    //   ABI.CLAIMFUND,
    //   PROVIDERS[CONFIG.CHAINNAME]
    // );
    // const _maxClaimCost = await contractInstance.maxClaimCost();
    // const _owner = await contractInstance.owner();
    // const _winner = await contractInstance.winner();
    const boostContract = CONTRACTS.WINBOOSTER[CONFIG.CHAINNAME]
    const [_maxClaimCost, _balance] = await Multicall([boostContract.maxFeePerPrize(userAddress),boostContract.balances(userAddress)],CONFIG.CHAINNAME)

    // const claims = await GetBoosterEvents(contractAddress, CONFIG.CHAINNAME);


    // const contractEthBalanceResult = await PROVIDERS[
    //   CONFIG.CHAINNAME
    // ].getBalance(contractAddress);

    const [claims, playerPrizeClaims] = await Promise.all([
        GetBoosterEvents(userAddress, CONFIG.CHAINNAME),
        fetch("https://poolexplorer.xyz/player-claims?address="+userAddress)
    ]);
 

    // console.log("got the player claims",await playerPrizeClaims.json())
      const playerPrizeClaimResults = await playerPrizeClaims.json()

    // const ethBalanceResult = await PROVIDERS[CONFIG.CHAINNAME].getBalance(user);
    // setEThBalance(ethBalanceResult.toString());
console.log("explorer player claims result?",playerPrizeClaimResults)
console.log("booster claims result",claims)
    let filteredClaims:any = [];
    if(claims){
        // Calculate Total Number of Indices per Event and Filter by User Address
        claims.forEach((claim:any) => {
            const totalIndicesCount = claim.indices.reduce((acc:any, indices:any) => acc + indices.length, 0);
            claim.totalIndicesCount = totalIndicesCount;
    
            if (claim.winners.includes(userAddress)) {
              console.log("found a match")
                const index = claim.winners.indexOf(userAddress);
                const userIndices = claim.indices[index];
                const userFeeShare = (userIndices.length / totalIndicesCount) * claim.fees;
    
                console.log("this?",{
                  vault: claim.vault,
                  tier: claim.tier,
                  winningIndices: userIndices,
                  feeShare: Math.round(userFeeShare),
                  transactionHash: claim.transactionHash
              })
                filteredClaims.push({
                    vault: claim.vault,
                    tier: claim.tier,
                    winningIndices: userIndices,
                    feeShare: Math.round(userFeeShare),
                    transactionHash: claim.transactionHash
                });
            }
        });
    
        // Find the payout value for each prize
        filteredClaims.forEach((filteredClaim:any) => {
            const prizeClaim = playerPrizeClaimResults.find((prizeClaim:any) => prizeClaim.hash === filteredClaim.transactionHash);
            if (prizeClaim) {
              console.log("prize claim",prizeClaim.payout)
                filteredClaim.onePrizeValue = prizeClaim.payout;
            }
        });
    
        console.log("after processing what we have here", filteredClaims);
    }
    



// console.log("updated claims",updatedClaims)

    setBoostedClaims(filteredClaims as any);
    setContractEthBalance(_balance.toString());
    setMaxClaimCost((parseFloat(_maxClaimCost as any) / 1e18).toFixed(4));
    // setFundContractAddress(contractAddress);
    // setWinnerAddress(_winner as any);
    // setOwnerAddress(_owner as any);
  };
  console.log("is creating new?", isCreatingNew);
  

  useEffect(() => {
    async function getPoolBalanceAndAllowance(userAddress: any) {
      const [ethBalanceResult,poolAllowanceFetched] = await Multicall([CONTRACTS.POOL[CONFIG.CHAINNAME].balanceOf(
        userAddress
      ),CONTRACTS.POOL[CONFIG.CHAINNAME].allowance(userAddress,ADDRESS[CONFIG.CHAINNAME].WINBOOSTER)],CONFIG.CHAINNAME)
      setEThBalance(ethBalanceResult.toString());
      // typescript dummy
      console.log("got balance",ethBalanceResult.toString(),"got allowance",poolAllowanceFetched.toString())
      const yo : ethers.BigNumber = poolAllowanceFetched as any
      setPoolAllowance(yo)
    }
    if (isConnected && address) {
      getPoolBalanceAndAllowance(address);
      setLoading(true);
      setOwnerAddress(address);
      // setWinnerAddress(address);
      setMaxClaimCost(DEFAULT_MAX_CLAIM_COST.toString());

      if (router.isReady) {
        const queriedContractAddress = router.query.address as string;
        const isNewContract = router.query.new === "true";
        // console.log("is new?", isNewContract);

        if (
          queriedContractAddress &&
          ethers.utils.isAddress(queriedContractAddress)
        ) {
          // Logic to handle viewing a specific contract by address
          // setFundContractAddress(queriedContractAddress);
          console.log("loading contract data yes")
          loadContractData(address);
          setLoading(false);
        } else if (isNewContract) {
          setIsCreatingNew(true);
          setLoading(false);
          console.log("new creating contract");
        } else {
          // Fetching contracts
          CONTRACTS.WINBOOSTER[CONFIG.CHAINNAME]
            .balances(
              address
            )
            .then((balance:any) => {
              // for (const event of events) {
              //   if (!event.args) continue;
              //   const { owner, claimer, contractAddress } = event.args as any;
              //   if (owner.toLowerCase() === address.toLowerCase()) {
                  // const contractInstance = new ethers.Contract(contractAddress, ABI.CLAIMFUND, PROVIDERS[CONFIG.CHAINNAME]);
                  // const _maxClaimCost = await contractInstance.maxClaimCost();
                  // const _owner = await contractInstance.owner();
                  // const ethBalanceResult = await PROVIDERS[CONFIG.CHAINNAME].getBalance(address);
                  // const contractEthBalanceResult = await PROVIDERS[CONFIG.CHAINNAME].getBalance(contractAddress);
                  // setContractEthBalance(contractEthBalanceResult.toString());
                  // setEThBalance(ethBalanceResult.toString());
                  // setMaxClaimCost((parseFloat(_maxClaimCost) / 1e18).toFixed(4));
                  // setFundContractAddress(contractAddress);

                  // const winner = await contractInstance.winner();
                  // setWinnerAddress(winner);
                  // setOwnerAddress(_owner);
              if(balance.gt(0)){
                  console.log("gt has deposited balance")
                  loadContractData(address)
              }else {console.log("0 no deposited balance")
            setContractEthBalance("0")
            }
              //     loadContractData(contractAddress);
              //     break;
              //   }
              // }

              setLoading(false);
            })

            .catch((error:any) => {
              console.error(error);
              setLoading(false);
            });
        }
      }
    }
  }, [
    isConnected,
    address,
    chain,
    createContractError,
    router.isReady,
    router.query,
    newWinBoostSucces,
    poolApproveSuccess,
    ethDepositSucces
  ]);

  console.log("allowance",poolAllowance?.toString())
  function isValidCreateContractInputs() {
    if(poolAllowance){
    if (
      isValidEthFunding(ethToAdd, ethBalance) &&
      ethers.utils.isAddress(ownerAddress) && 
      parseFloat(ethers.utils.formatUnits(poolAllowance,ADDRESS[CONFIG.CHAINNAME].PRIZETOKEN.DECIMALS)) >= parseFloat(ethToAdd)
      // ethers.utils.isAddress(winnerAddress) &&
      // isValidMaxClaimCost(maxClaimCost)
    ) {
      console.log("its valid now");
      return true;
    } else {
      // console.log(
      //   "create validation fail",
      //   ethers.utils.isAddress(ownerAddress),
      //   ethers.utils.isAddress(winnerAddress),
      //   ethers.utils.isAddress(claimerAddress)
      // );
      // console.log("funding", isValidEthFunding(ethToAdd, ethBalance));
      // console.log("max claim cost", isValidMaxClaimCost(maxClaimCost));

      return false;
    }}else{return false}
  }

function netBoost(claims:any) {
  let totalSum = ethers.BigNumber.from(0);

claims.forEach((item:any) => {
  console.log("item",item.onePrizeValue,item)
  const onePrizeValue = item.onePrizeValue ? ethers.BigNumber.from(item.onePrizeValue) : ethers.BigNumber.from(0);
  const feeShare = ethers.BigNumber.from(item.feeShare.toString());
    const lengthOfIndices = item.winningIndices.length;

    const totalForItem = onePrizeValue.mul(lengthOfIndices).sub(feeShare);
    totalSum = totalSum.add(totalForItem);
});

console.log(totalSum.toString());
return totalSum.toString()
}

return (<>
    <Layout>
        <center>
      <div
        style={{
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
        }}>
        <Image
          src={`/images/boost.png`}
          height={90}
          width={105}
          alt="boost"
          style={{ verticalAlign: "middle" }}
        />
        <h1 style={{ margin: "0 0 0 10px", lineHeight: "120px" }}>
          WIN BOOSTER
        </h1>
      </div>
      <br></br>
      {loading ? (
        // Loading State
        <div className="loading-animation">
          <div className="loading-image">
            <Image src={donut} alt="Loading" priority={true} />
          </div>
        </div>
      ) : chain && chain.id === 10 ? (
        // Main Content
        Number(contractEthBalance) > 0 && !isCreatingNew ? (
          // Display User info
<>      {address && <>
          <PrizeTokenBalance  address={address} chain={chain?.id}/><br></br><br></br></>}
          <div className="vault-content">
            <div>
              <div className="eth-section"></div>

              {parseFloat(contractEthBalance) > 0 && (
                <div className="data-row">
                  <div className="contract-label">Contract Balance
                  &nbsp;
                      <div className="tooltipContainer">
                    <Image src="/images/moreInfo.svg" alt="i" width={16} height={16}/>
                    <span className="tooltipText">
                       The amount of POOL you have funded for boosts. Recommended minimum of 0.5 POOL.
                    </span>
                </div>
                  </div>
                  <div className="contract-data font-16">
                    {" "}
                    {(parseFloat(contractEthBalance) / 1e18).toFixed(4)}
                    &nbsp;POOL &nbsp;&nbsp;
                    { address &&
              address.toLowerCase() === ownerAddress.toLowerCase() &&
                    <button
                      className="button-purple"
                      onClick={() => withdrawEth()}
                      disabled={
                        isWithdrawingEth ||
                        !(parseFloat(contractEthBalance) > 0)
                      }>
                      {isWithdrawingEth ? (
                        <span className="spinner-small"></span>
                      ) : (
                        "WITHDRAW"
                      )}
                    </button>}
                  </div>
                </div>
              )}
              {address &&
              address.toLowerCase() === ownerAddress.toLowerCase() ? (
                <>
                  <div className="data-row">
                    <div className="contract-label">
                    <span style={{ color: "#cd3e2f" }} className="small-font">
                    {
                    
                    parseFloat(ethToAdd) + parseFloat(contractEthBalance)/1e18 > MAX_ETH_FUNDING
                      ? `Warning: Max Balance ${MAX_ETH_FUNDING} `
                      : parseFloat(ethToAdd) > parseFloat(ethBalance) / 1e18
                      ? `Insufficient POOL wallet balance`:
                      parseFloat(ethToAdd) < MIN_ETH_FUNDING
                      ? `Warning: Min funding of ${MIN_ETH_FUNDING} `:
                      ""
                      }
                      </span>
                      {/* <div className="awesome-icon">
                        <FontAwesomeIcon
                          icon={faWallet}
                          size="sm"
                          style={{ color: "#21325c" }}
                        />
                      </div>
                      &nbsp;
                      <span className="small-font">
                        {(parseFloat(ethBalance) / 1e18).toFixed(4)} POOL
                      </span> */}
                    </div>
                    <div className="contract-data">
                      {/* <input
                          type="text"
                          className="contract-input-field"
                          value={ethToAdd}
                          onChange={(e) => setEthToAdd(e.target.value)}
                          placeholder="Enter amount of ETH"
                        /> */}
                      <input
                        type="text"
                        value={ethToAdd}
                        className="contract-input-field width-130"
                        placeholder="POOL"
                        onChange={(e) => {
                          const val = e.target.value;
                          if (isNumericInput(val)) {
                            setEthToAdd(val);
                          }
                        }}
                      />
                      {poolAllowance && parseFloat(ethers.utils.formatUnits(poolAllowance,ADDRESS[CONFIG.CHAINNAME].PRIZETOKEN.DECIMALS)) > parseFloat(ethToAdd) || ethToAdd === ""?
                      
                      <button
                        className="button-purple"
                        onClick={() => depositPool()}
                        disabled={
                          isDepositingEth ||
                          !isValidEthFunding(ethToAdd, ethBalance) || ethToAdd === ""
                        }>

                      {isDepositingEth ? (
                        <span className="spinner-small"></span>
                      ) :
                        <>ADD POOL</>}
                      </button>:
                      <button
                        className="button-purple"
                        onClick={() => approvePool()}
                        disabled={
                          poolApproveLoading
                          
                        }>

                      {isApprovingPool ? (
                        <span className="spinner-small"></span>
                      ) :
                        <>APPROVE</>}
                      </button>}
                    </div>
                  </div>
                  <br></br>

                  <div className="max-claim-cost-section">
                    <div className="data-row">
                      <div className="contract-label">Max Claim Cost&nbsp;
                      <div className="tooltipContainer">
                    <Image src="/images/moreInfo.svg" alt="i" width={16} height={16}/>
                    <span className="tooltipText">
                       The maximum value per prize the booster can spend to claim your win.
                    </span>
                </div>
                      </div>
                      <div className="contract-data">
                        <input
                          type="text"
                          className="contract-input-field width-130"
                          value={maxClaimCost}
                          onChange={(e) => setMaxClaimCost(e.target.value)}
                        />
                        <button
                          className="button-purple"
                          onClick={() => updateMaxClaimCost()}
                          disabled={
                            updateMaxClaimCostIsLoading ||
                            !isValidNumberInput(maxClaimCost)
                          }>
                            {updateMaxClaimCostIsLoading ? (
                        <span className="spinner-small"></span>
                      ) :
                          <>UPDATE</>}
                        </button>
                      </div>
                    </div>
                  </div>
                </>
              ) : (
                ""
              )}
                  {boostedClaims.length > 2 && <div className="data-row">
                    <div className="contract-label"><div className="total-boosts">Boost Net 
                    <PrizeIcon size={15}/>&nbsp;+{PrizeToke(BigInt(netBoost(boostedClaims)))}</div></div></div>} 
              {boostedClaims.length > 0 && (
                <>
                  <br></br>
                  <div className="claimboost-table">
                    <div className="claimboost-table-header">
                      <div className="header__item">BOOSTED WINS</div>
                      <div className="header__item hidden-mobile">Tier</div>
                      <div className="header__item">Prizes</div>
                      <div className="header__item">Cost</div>
                    </div>
                    <div className="claimboost-table-content">
                      {boostedClaims.map((event:any, index:any) => (
                        <div key={index} className="claimboost-table-row">
                                                      {event.onePrizeValue ? <>

                          <div className="claimboost-table-data">
                          <PrizeIcon size={15}/>&nbsp;&nbsp;
                            {((parseFloat(event.onePrizeValue)/1e18)*event.winningIndices.length).toFixed(4)}
                          </div>
                          <div className="claimboost-table-data hidden-mobile">
                            {event.tier}
                          </div>
                          <div className="claimboost-table-data">
                            {event.winningIndices.length}
                          </div></>: <><div className="claimboost-table-data"></div><div className="claimboost-table-data"></div><div className="claimboost-table-data"></div></>}
                          <div className="claimboost-table-data"><PrizeIcon size={15}/>&nbsp;&nbsp;
                          {
  
                        `${parseFloat(ethers.utils.formatUnits(event.feeShare.toString(), 18)).toFixed(5)}` 
  
                          }

                          </div>
                          <a
                            href={`${ADDRESS[CONFIG.CHAINNAME].ETHERSCAN}/tx/${event.transactionHash}`}
                            target="_blank"
                            rel="noreferrer">
                            <Image
                              src="/images/etherscan.svg"
                              height={14}
                              width={14}
                              alt="Etherscan"
                            />
                          </a>
                        </div>
                      ))}
                    </div>
                  </div>
                </>
              )}

              {/* <br></br>
              <hr className="condensed-hr" />
              <br></br>

              <AddressRow name="Contract" address={fundContractAddress} />
              <br></br>
              <AddressRow name="Owner" address={ownerAddress} />
              <br></br>
              <AddressRow name="Winner" address={winnerAddress} />
              <br></br>
              <AddressRow name="Claimer" address={claimerAddress} /> */}
            </div>
          </div></>
        ) : 
        (contractEthBalance &&
          // Create New Contract Form
          <>
          {address && <>
          <PrizeTokenBalance  address={address} chain={chain?.id}/><br></br><br></br></>}
          
          <div className="vault-content">
            <div>
              <div className="full-width-header">
                <div className="sub-light-flex">
                  Create and fund a win booster. The POOL funding
                  will be used to make boosted claims for the winner and can be
                  withdrawn by the winner any time. 
                </div>
              </div>
              <br></br>
              {poolAllowance?.gt(0) ? <>
              <div className="data-row">
                <div className="contract-label">Fund your booster with POOL</div>
                <div className="contract-data">
                  <input
                    type="text"
                    value={ethToAdd}
                    className="contract-input-field"
                    placeholder="Enter amount"
                    onChange={(e) => {
                      const val = e.target.value;
                      if (isNumericInput(val)) {
                        setEthToAdd(val);
                      }
                    }}
                  />
                </div>
              </div>
              <br></br>
              <div className="data-row">
                <div className="contract-label">Winner</div>
                <div className="contract-data">
                  <input
                    type="text"
                    className="contract-input-field width-250"
                    value={ownerAddress}
                    onChange={(e) => setOwnerAddress(e.target.value)}
                  />
                </div>
              </div></>:<>Step 1 - Approve POOL to fund your booster<br></br></>}
              {/* <br></br>
              <div className="data-row">
                <div className="contract-label">Winner</div>

                <div className="contract-data">
                  <input
                    type="text"
                    className="contract-input-field width-250"
                    value={winnerAddress}
                    onChange={(e) => setWinnerAddress(e.target.value)}
                  />
                </div>
              </div>
              <br></br>
              <div className="data-row">
                <div className="contract-label">Max Claim Cost</div>

                <div className="contract-data">
                  <input
                    type="text"
                    value={maxClaimCost}
                    className="contract-input-field"
                    placeholder="Enter Max Claim Cost"
                    onChange={(e) => {
                      const val = e.target.value;
                      if (isNumericInput(val)) {
                        setMaxClaimCost(val);
                      }
                    }}
                  />
                </div>
              </div> */}
              <br></br>
              <div className="data-row">
                <div className="contract-label">
                  {isValidCreateContractInputs() && (
                    <button
                      style={{ width: "180px" }}
                      className="button-purple"
                      onClick={() => depositPool()}
                        disabled={
                          isDepositingEth ||
                          !isValidEthFunding(ethToAdd, ethBalance)
                        }>
                      {isWritingNewFundContract && poolAllowance?.gt(0)? (
                        <>
                          <span className="spinner-small"></span>SENDING TX
                        </>
                      ) : (
                        "FUND BOOSTER"
                      )}
                    </button>  )}
                    {poolAllowance?.eq(0) && <center><button
                      style={{ width: "180px" }}
                      className="button-purple"
                      onClick={() => approvePool()}
                        disabled={
                          poolApproveLoading 
                        }>
                      { (isApprovingPool || poolApproveLoading) && poolAllowance?.gt(0)? (
                        <>
                          <span className="spinner-small"></span>SENDING TX
                        </>
                      ) : (
                        "APPROVE POOL SPEND"
                      )}
                    </button></center>}
                
                </div>
                <div className="contract-data">{poolAllowance &&
                  <span style={{ color: "#cd3e2f" }} className="small-font">
                    {" "}
                    {poolAllowance.eq(0)? ``:
                    !ethToAdd ||
                    isNaN(parseFloat(ethToAdd)) ||
                    parseFloat(ethToAdd) < MIN_ETH_FUNDING ||
                    parseFloat(ethToAdd) > MAX_ETH_FUNDING
                      ? `Required: POOL funding between ${MIN_ETH_FUNDING} and ${MAX_ETH_FUNDING}`
                      : parseFloat(ethToAdd) > parseFloat(ethBalance) / 1e18
                      ? `Insufficient POOL wallet balance`
                      : !ethers.utils.isAddress(ownerAddress)
                      ? "Required: Valid owner address"
                      : parseFloat(ethers.utils.formatUnits(poolAllowance,ADDRESS[CONFIG.CHAINNAME].PRIZETOKEN.DECIMALS)) < parseFloat(ethToAdd)
                      ? "Insufficient allowance for spend"
                      // : !ethers.utils.isAddress(winnerAddress)
                      // ? "Required: Valid winner address"
                      : !maxClaimCost ||
                        isNaN(parseFloat(maxClaimCost)) ||
                        parseFloat(maxClaimCost) <= 0 ||
                        parseFloat(maxClaimCost) > MAX_CLAIM_COST
                      ? `Required: A max claim cost less than ${MAX_CLAIM_COST}`
                      : ""}
                  </span>}
                </div>
              </div>
            </div>
          </div></>
                    )
                     ) : (
          // Wrong Chain State
          !address ? <div className="vault-content">
              <div className="full-width-header">
                <div className="sub-light-flex">
                Create and fund a win booster. The POOL funding
                  will be used to make boosted claims for the winner and can be
                  withdrawn by the winner any time. 
                </div>
              </div><br></br>
          <div>
          <FontAwesomeIcon
            icon={faExclamationCircle}
            size="sm"
            style={{
              color: "#21325c",
              height: "18px",
              marginRight: "8px",
              marginLeft: "5px",
            }}
          />{" "}
          Connect wallet to booooost
              </div><br></br>
            </div> :
        <div className="vault-content">
          <div className="full-width-header">
                <div className="sub-light-flex">
                Create and fund a win booster. The POOL funding
                  will be used to make boosted claims for the winner and can be
                  withdrawn by the winner any time. 
                </div>
              </div><br></br>
          <div>
            <FontAwesomeIcon
              icon={faExclamationCircle}
              size="sm"
              style={{
                color: "#21325c",
                height: "18px",
                marginRight: "8px",
                marginLeft: "5px",
              }}
            />{" "}
            Wrong chain
          </div><br></br>
        </div>
      )
      
      }</center>
     
    </Layout><ToastContainer /> </>
  );
};

export default WinBoostComponent;
